#!/bin/python3

import os
import re
import sys
import json
import getopt
import pygit2
import json

#    def __init__(self, args, taskdir):
#        self.task_brd = args["brd"]
#        self.task_id = args["id"]
#        self.task_prj = args["prj"]
#        self.files = {}
#        self.dirs = {}
#
#        self.dirs.update({"pgndir" : "/".join([taskdir, ".pgn/gun"])}) # TODO: rename it to gmux
#        self.dirs.update({"dirdb" : "/".join([taskdir, args["prj"], args["id"], ".tman"])})
#        self.files.update({"sysunit" : "/".join([self.dirs["dirdb"], "unit"])})
#        self.files.update({"pgnunit" : "/".join([self.dirs["dirdb"], "pgn/gun"])})
#
#        print("pgndir", self.dirs["pgndir"])
#        self.basic = GMUXHelper.generate_basic(self, args["prj"], args["brd"], args["id"], taskdir)
#
#        # TODO: add default values in case config is empty for a project
#        self.config = GMUXHelper.get_config(self).get(args["prj"]) or {}
#
#        # Set default values to repos got from config
#        self.config["repos"] = self.config.get("repos") or {}
#        for repo in self.config["repos"]:
#            repo["path"] = repo.get("path") or "/".join([ self.dirs["pgndir"], repo["name"] ])
#
#        self.config["prefix"] = self.config.get("prefix") or "T"
#
#        self.config["repodir"] = self.config.get("repodir") or "repos" # TODO: use '.'
#        self.config["repodir"] = "/".join([ taskdir, args["prj"], args["id"], self.config["repodir"] ])
#        if not os.path.isdir(self.config["repodir"]):
#            os.mkdir(self.config["repodir"])
#
#        self.config["commitpatt"] = self.config.get("commitpatt") or "[ID] PART: MSG"
#        self.config["branchpatt"] = self.config.get("branchpatt") or "TYPE/PREFIX-ID_DESC_DATE"
#
#        self.helper = GMUXHelper()

PluginName = "gmux"
Version = "v0.0.1"

"""
config

dirdb       # for builtin and plugin unit files
config      # project config

dirs: .tman/pgn - make sure it's created
files: .tman/unit, .tman/pgn/gmux
args - prj, brd, id

"""


"""
classes:
    config: (read from file, if not then set defaults)
    unit: (read from and write to)
    basic: (for dirs and files)
"""

"""
taskdir - where task are stored
pgndir  - where plugin date is located
repodir - where is repo symlink located in task
"""


"""
TODO:
    5. Add support for worktree.
    6. Add support for submodules.
"""

class Config:
    def __init__(self, taskdir):
        self.taskdir = taskdir
        self.config = {}
        self.prjconf = {}

    def find_file(self):
        files = {
            "{}/.tman/pgns/gmux.json".format(os.environ["HOME"]),
            "{}/.config/tman/pgns/gmux.json".format(os.environ["HOME"]),
        }
        for file in files:
            if os.path.exists(file):
                return file
        return None

# repo {'name': 'OpenWRT', 'branch': 'openwrt-23.05', 'link': 'git@gitlab.wimark.com:embedded/OpenWRT.git', 'path': ''}
#repo {'name': 'demo', 'branch': 'main', 'link': 'https://github.com/roachme/demo.git', 'path': ''}

    def set_defaults(self, prj, taskid):
        # basic.repodir = basic.base .. '/' .. '.pgn/gun'
        # TODO: rename gun to gmux
        self.config.update({"pgndir" : "/".join([self.taskdir, ".pgn/gun"])})
        for repo in self.config[prj]["repos"]:
            repo["path"] = "/".join([self.config["pgndir"], repo["name"]])

        self.config[prj]["pgndir"] = "/".join([self.taskdir, ".pgn/gun"])
        self.config[prj]["prefix"] = "PR"
        return self.config[prj]


    def get(self, prj, taskid):
        fname = self.find_file()
        if fname is None:
            return self.set_defaults(prj, taskid)

        with open(fname, 'r') as file:
            self.config = json.load(file)
            return self.set_defaults(prj, taskid)
        return self.prjconf

    def set(self):
        pass


# Separet branch pattern into items
def pattsplit(inputstr, sep):
    return re.split("[-_/]", inputstr)

def branch_generate(branchpatt, sysunits):
    pass

def die(msg):
    print(f"{PluginName}: ", end='')
    print(msg)
    sys.exit(1)

def usage():
    print(
        f"Usage: {PluginName} [OPTION]... COMMAND [OPTION]... [ARG]...\n"
        "\n"
        "Options:\n"
        "  -h       show this help message and exit\n"
        "  -q       do not output to standart error output\n"
        "  -T       path to task directory\n"
        "  -V       show verison and exit\n"
        "\n"
        "COMMANDs:\n"
        "  show     show plugin units\n"
        "  help     show this help message and exit")
    return 0

def version():
    print(f"{PluginName}: {Version}")


class GMUXHelper:
    def clone(self, repos):
        for repo in repos:
            try:
                if not os.path.isdir(repo["path"]):
                    print("link", repo["link"])
                    print("path", repo["path"])
                    _repo = pygit2.clone_repository(repo["link"], repo["path"])
            except pygit2.GitError as e:
                print(f"error repo: {e}")

    def symlink(self, repos, task_repodir):
        if not os.path.isdir(task_repodir):
            os.mkdir(task_repodir)
        print("[-] create symlinks")
        for repo in repos:
            src = repo["path"]
            dst = "/".join([task_repodir, repo["name"]])
            print("src", src)
            print("dst", dst)
            if not os.path.islink(dst):
                os.symlink(src, dst)

    def check_changes(self, repos, repodir):
        print("[-] check changes")
        status = True

        for repo in repos:
            _repo = pygit2.Repository("/".join([ repodir, repo['name'] ]))
            if len(_repo.status()) > 0:
                print("uncommitted changes in repo:", repo['name'])
                status = False
        return status


    def branch_create(self, repos, branchname):
        print("[-] make branches")
        for repo in repos:
            pass

    def branch_switch(self):
        print("[-] make branches")
        pass

    def get_config(self):
        fname = "{}/.config/tman/pgns/gmux.json".format(os.environ["HOME"])
        if not os.path.isfile(fname):
            return {}
        try:
            with open(fname, 'r') as file:
                config = json.load(file)
                return config
        except:
            print("error: error in config")
            return None

    def generate_basic(self, prj, brd, taskid, taskdir):
        config = GMUXHelper.get_config(self).get(prj) or {}
        config.update({"taskdir": "/".join([taskdir, prj, taskid]) })
        config.update({"unitdir": "/".join([config["taskdir"], '.tman']) })
        config.update({"sysfile": "/".join([config['unitdir'], '.tman']) })
        config.update({"fpgn": "/".join([config['unitdir'], 'pgn/gun']) }) # TODO: Rename it to gmux
        return config

    def merge_merge(self):
        pass

    def merge_rebase(self):
        pass

    def merge_cherrypick(self):
        pass


class Unit:
    def __init__(self, fname):
        self.fname = fname

    def load(self):
        units = {}
        if not os.path.isfile(self.fname):
            print(f"plugin unit file is missing '{self.fname}'")
            return None
        with open(self.fname, 'r') as file:
            for line in file:
                key, val = line.strip().split(" : ")
                units.update({key : val})
        return units

    def set(self, units):
        pass

    def save(self):
        pass


def _config_default():
    pass

def _load_config(filename):
    with open(filename, 'r') as file:
        pass

def load_config():
    files = {
        "/home/roach/.tman/pgn/gmux.json",
        "/home/roach/.config/tman/pgn/gmux.json",
    }
    for file in files:
        if os.path.exists(file):
            return _load_config(file)
    return _config_default()

"""
dirs: .tman/pgn - make sure it's created
files: .tman/unit, .tman/pgn/gmux
args - prj, brd, id
"""
class GMUX(GMUXHelper):
    def __init__(self, sysopts):
        self.taskdir = sysopts.get("taskdir")
        pass

    def commit(self, basic, arguments):
        pass

    def delete(self, basic, arguments):
        pass

    def help(self, basic, arguments):
        return usage()

    def init(self, basic, arguments):
        pass

    # TODO: direction: forward and reverse, i.e.
    #     1. rebase against main branch
    #     2. or update task branch
    # TODO: add option like: rebase, merge and cherrypick
    def merge(self, basic, arguments):
        pass

    def show(self, basic, arguments):
        args = {}

        try:
            opts, _args = getopt.getopt(arguments, ":b:i:p:")
            for opt, arg in opts:
                if opt == "-b":
                    args.update({"brd": arg})
                elif opt == "-i":
                    args.update({"id": arg})
                elif opt == "-p":
                    args.update({"prj": arg})
                else:
                    die(f"option {opt} requires an argument")
            # Check input arguments
            # TODO: Add check for board
            if args.get("id") is None:
                die("no current task ID")
            elif args.get("prj") is None:
                die("no current project")
        except getopt.GetoptError as err:
            die(f"{err}")

        # TODO: replace gun with gmux in the filename below
        unitfile = "/".join([self.taskdir, args["prj"], args["id"], ".tman/pgn/gun"])
        units = Unit(unitfile).load()
        # TODO: add a padding to output
        if units is not None:
            for key in units:
                print(f"{key} : {units[key]}")
            return 0
        die("could not get gmux unit file content")

    def sync(self, basic, arguments):
        args = {}

        try:
            opts, _args = getopt.getopt(arguments, ":b:i:p:")
            for opt, arg in opts:
                if opt == "-b":
                    args.update({"brd": arg})
                elif opt == "-i":
                    args.update({"id": arg})
                elif opt == "-p":
                    args.update({"prj": arg})
                else:
                    die(f"option {opt} requires an argument")
            # Check input arguments
            # TODO: Add check for board
            if args.get("id") is None:
                die("no current task ID")
            elif args.get("prj") is None:
                die("no current project")
        except getopt.GetoptError as err:
            die(f"{err}")

        unitfile = "/".join([self.taskdir, args["prj"], args["id"], ".tman/unit"])
        sysunits = Unit(unitfile).load()
        unitfile = "/".join([self.taskdir, args["prj"], args["id"], ".tman/pgn/gun"])
        units = Unit(unitfile).load()

        config = Config(basic["taskdir"])
        config = config.get(args["prj"], args["id"])

        # Make sure all needed repos are cloned
        GMUXHelper.clone(self, config["repos"])

        # Create all needed symlinks in task directory
        task_repodir = "/".join([self.taskdir, args["prj"], args["id"], "repos"])
        GMUXHelper.symlink(self, config["repos"], task_repodir)

        # check that all repos has no changes
        if GMUXHelper.check_changes(self, config["repos"], task_repodir) == False:
            print("ERROR: has uncommitted changes")
            return 1
        return 0

        # Create task branch in all repos (maybe not all tho)
        GMUXHelper.branch_create(self, config["repos"], branchname)

        # Switch to task directory
        # Rebase against default branch (use an option for it)
        pass

    def rsync(self, basic, arguments):
        pass



def main():
    basic = {}

    # Parse plugin options
    i = 1
    option = sys.argv[i]
    while i < len(sys.argv) and sys.argv[i][0:1] == '-':
        option = sys.argv[i]
        if option == "-h":
            return usage()
        elif option == "-T":
            if i + 1 == len(sys.argv):
                die(f"option `{option}' requires an arguments")
            basic.update({"taskdir": sys.argv[i + 1]})
            i = i + 1
        elif option == "-V":
            return version()
        else:
            die(f"no such option: `{option}'")
        i = i + 1

    command = sys.argv[i] if i < len(sys.argv) else die("no command passed")
    arguments = sys.argv[i + 1:]

    gmux = GMUX(basic)
    commands = [
        { "name" : "commit", "func" : gmux.commit },
        { "name" : "init", "func" : gmux.init },
        { "name" : "show", "func" : gmux.show },
        { "name" : "help", "func" : gmux.help },
        { "name" : "sync", "func" : gmux.sync },
        { "name" : "rsync", "func" : gmux.rsync },
    ]

    for cmd in commands:
        if command == cmd["name"]:
            return cmd["func"](basic, arguments)

    die(f"'{command}': no such command")



def branch_generate(branchpatt, sysunits):
    separators = "/_-"
    sepcomponents = pattsplit(branchpatt, separators)

    for item in sepcomponents:
        #uitem = sysunits[string.lower(item)]
        print(item, item.lower())

    print()
    for item in sysunits:
        print("sysunit", item)


sysunits = Unit("/home/roach/trash/tman/test/test1/.tman/unit").load()
branchpatt = "TYPE/PREFIX-ID_DESC_DATE"
res = branch_generate(branchpatt, sysunits)
print(res)


if __name__ == "__main__":
    #main()
    pass
